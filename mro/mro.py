'''
一个class 从父类里找应该优先使用那个父类的方法的过程就叫做MRO
method resolution order
'''

class A:
    def say(self):
        print("A")

class B:
    def say(self):
        print("B")

class C(A, B):
    pass

print(C.mro())
c = C()
c.say()


# [<class '__main__.C'>, <class '__main__.A'>, <class '__main__.B'>, <class 'object'>]
# 线性化serialization
# 遵循三条原则：
# 1. 子类优先于父类
# 2. 多个父类根据其在列表中的顺序被检查
# 3. 如果对下一个类存在两个合法的选择，选择第一个父类

# 使用了C3算法
'''
C3算法保证了三件事情：
1. MRO里任意两个类的相对顺序和自己所有父类的MRO里这两个类的相对顺序一致。（第三条，单调性）
2. MRO里任意两个类的相对顺序和继承图里所有直接继承自这两个类的类在程序中声明的相对顺序一致。（第二条）
3. 如果两个类不具有直接的继承关系，那么找到两个类的最小公共子类，这个最小公共子类的多继承顺序靠前的分支上的类具有高优先级。（第一条）

第三条单调性体现了子类MRO和自己所有父类的MRO之间的*顺序关系*，第一、二条是规定具体某两个类在所有涉及这两个类的MRO中，*它们之间*的顺序关系...大概可以这样理解吧

'''
